// super 关键字


// super关键字
//
// (1)概念
//  super代表父类的引用，用于访问父类的属性、方法、构造器
//  (super表示父类对象，可以类比this表示本类对象)
//
//
// (2)语法
//  1.访问父类属性：super.属性;
//  2.访问父类方法：super.方法(参数列表);
//  3.访问父类构造器：super(参数列表);// 注意：必须放在子类构造器的第一行：先构造父，后构造子
//
//
//
// (3)super和this【重点】
//  ① this本质：本类对象 【本类对象中包含父类对象】
//     super本质：(子类对象中包含的)父类对象
//  ②访问范围
//     this.成员：包括本类成员、父类成员...一直追溯到Object类成员
//              查找规则：(就近原则)先查找子类的新增成员，再查找父类...
//     super.成员：包括父类成员、爷爷类成员...一直追溯到Object类成员
//              查找规则：(就近原则)先查找父类的新增成员，再查找爷爷类...
//
//
//
// (4)super细节
//  1.super关键字只能访问到父类中权限允许的成员
//      如：父类的private成员只能在父类内部访问，子类中用super对象也无法访问
//
//  2.使用super(...)调用父类构造器的好处：
//      分工明确，父类属性由父类初始化，子类属性由子类初始化
//
//  3.①当父类和子类中有重名的成员(属性或方法)时：
//      由于【查找关系遵循就近原则】，在子类中访问重名成员时，默认得到子类中新增的成员
//      若想在子类中访问到父类的重名成员，需要通过super关键字
//    ②若成员未重名，用super、this或直接访问父类成员效果都一样
//
//  4.super的访问不限于直接父类：
//      若父类中没有，但爷爷类中有子类的同名成员，super会访问到爷爷类的成员
//      本质：super是父类对象，父类对象中包含爷爷类对象。




package com._05_super;

public class Super_ {
    public static void main(String[] args) {
        Sub s = new Sub();
        System.out.println(s.info());// n1=100, n2=200, n3=300, n4=400
        s.callVar();
        s.callFunc();
        // func1调用
        // func2调用
        // func3调用
        System.out.println(s.info());// n1=1, n2=2, n3=3, n4=400
    }
}
