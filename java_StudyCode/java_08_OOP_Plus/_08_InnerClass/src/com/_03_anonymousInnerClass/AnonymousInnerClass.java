// anonymous inner class：匿名内部类


// 匿名内部类
//
// (1)概念
//  匿名内部类在外部类的局部位置，如方法、代码块中。
//  匿名内部类没有类名。必须在定义匿名内部类的同时创建对象，否则之后就找不到这个类了。
//  匿名内部类必须基于已有的接口或类来定义，它可以被看作是对已有接口或类的扩展和特殊化。
//
//
// (2)语法
//  1.基本语法：
//  new 类/接口(参数列表) {
//      匿名内部类体(重写方法)...
//  };
//  2.这里以方法中的匿名内部类为例：
//  public class Outer {// 外部类
//      ...
//      public void method() {// 外部类方法
//          ...
//          // ①基于接口的匿名内部类
//          接口名 对象1 = new 接口名() {
//              重写接口方法...
//          };
//
//          // ②基于类的匿名内部类
//          类名 对象2 = new 类名(参数列表) {
//              [重写类方法...]
//          };
//      }
//  }
//
//
//  (3)定义方式
//  Java的匿名内部类，【只能基于已有的接口或类来定义】，它不能独立存在。
//  原因：1.匿名内部类没有类名，但是引用变量的编译类型必须通过有名称的类型来声明，（运行类型没有这个要求），
//         因此，匿名内部类必须基于已有的接口或类来实现，才能让已有类型的引用，指向匿名内部类对象
//       2.匿名内部类需要通过已有的类或接口为它提供一个基本框架，这种设计是为了保证代码的可读性和可维护性
//  本质：匿名内部类，是对已有的类(接口)进行继承(实现)
//
//
//
// (4)特点
//  1.匿名内部类定义在外部类的局部位置。因此，匿名内部类也具有局部内部类的性质。
//    ①可以直接访问外部类的全部成员
//    ②其地位和局部变量相同。不能用访问修饰符、static等修饰
//    ③作用域仅在定义它的方法或代码块中
//    ④若外部类和匿名内部类的成员重名，访问遵循就近原则。
//      若想在匿名内部类中访问重名的外部类成员，可以使用(外部类名.this.成员)
//
//  2.匿名内部类只能在定义类的同时实例化对象，离开这条语句后就找不到这个匿名类了。
//
//  3.匿名内部类只能基于已有的接口或类来定义，其本质是匿名类对已有类的继承/已有接口的实现。
//
//  4.匿名内部类没有类名，但是系统会在底层为其分配一个无法调用的默认类名。(格式：外部类名$匿名类的序号)
//      如：外部类Outer中创建的第3个匿名内部类，默认类名为 Outer$3（可以用getClass()验证）
//      注意：虽然底层会默认为匿名内部类分配类名，但是该类名仅供系统使用，程序员无法手动对该类名进行任何操作（因此，可以认为匿名内部类没有类名）
//
//
//
// (5)应用场景
//  应用场景：将匿名内部类直接作为参数传参（因为匿名内部类在定义的同时创建对象）
//  e.g. 用匿名对象传参：func(new Person("张三"));// 实参为Person类的匿名对象
//       匿名内部类传参：func(new Person("李四") {重写方法...});// 实参为匿名内部类的匿名对象
//  代码在test02中...




package com._03_anonymousInnerClass;

public class AnonymousInnerClass {
    public static void main(String[] args) {

        // (1)测试基于接口的匿名内部类
        // 注意：外部类Outer01中，第1个匿名内部类（由系统自动分配）的类名为Outer01$1
        new Outer01().method1();
        //好虎在吃肉
        //老虎在叫唤
        //class com._03_anonymousInnerClass.Outer01$1

        new Outer01().method2();
        //class com._03_anonymousInnerClass.Outer01$2


        // (2)测试基于类的匿名内部类
        System.out.println("================");
        new Outer02().method01();
        //================
        //work方法被调用
        //class com._03_anonymousInnerClass.Outer02$1
        //================
        //李四 在上班
        //class com._03_anonymousInnerClass.Outer02$2

        System.out.println("================");
        new Outer02().method02();
        //王五 在工作
        //class com._03_anonymousInnerClass.Outer02$3
    }
}
