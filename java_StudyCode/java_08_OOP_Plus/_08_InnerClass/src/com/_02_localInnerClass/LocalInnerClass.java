// local inner class：局部内部类


// 局部内部类
//
// (1)概念
//  局部内部类是定义在【外部类中的局部位置】，比如方法/代码块中，并且有类名
//
//
// (2)语法
//  这里以方法中的局部内部类为例：
//  public class Outer {// 外部类
//      ...
//      public void method() {// 外部类方法
//          ...
//          class Inner {// 局部内部类
//              ...
//          }
//      }
//  }
//
//
// (3)特点【重点】
//  1.由于局部内部类在类内，因此它可以直接访问外部类的所有成员
//
//  2.【局部内部类的地位和局部变量相同】，因此二者规则有很多相似之处
//    例如：局部内部类也不能用访问修饰符、static等关键字修饰，不过可以用final修饰(表示不能被继承)
//
//  3.作用域：仅在定义它的方法或代码块中
//    若想在外部类中访问局部内部类的成员，需要创建对象（前提是在局部内部类的作用域下）
//    注意：外部其他类，不能访问局部内部类（局部内部类和局部变量是一个级别，作用域只在方法体/代码块内）
//
//  4.局部内部类也是类，它具有类的一切性质
//
//  5.若外部类和局部内部类的成员重名时，访问遵循【就近原则】
//      若想在局部内部类中访问重名的外部类成员，可以使用(外部类名.this.成员)去访问
//      注意：尽管可以通过(类名.this)找到this，但是this不是静态的（this代表每个当前的对象），
//           以上只是一种特殊写法，类名在这里表示this当前的类型
//
//
//
// (4)注意事项
//  1.Java的外部类中(内部类外)创建的局部内部类对象，可以直接访问局部内部类(新增)的private成员（注意：只能访问内部类新增的private成员，不能访问从外部父类中继承的private成员）
//    这可以理解为：内部类是外部类的成员，因此外部类中可以通过对象直接访问内部类的private属性
//    注意：这是一种特例，实际上该内部类对象在底层中是直接创建在内部类中的，因此可以直接访问其private属性
//    然而，这种做法并不推荐，因为它破坏了类的封装性，使得代码难以理解和维护




package com._02_localInnerClass;

public class LocalInnerClass {
    public static void main(String[] args) {
        Outer outer = new Outer();

        outer.testLocalInnerClass1();
        //testLocalInnerClass1方法被调用
        //innerNum=200
        //outerNum=100
        //outerFunc方法被调用

        outer.testLocalInnerClass3();
        //10
        //20
        //20
        //10
    }
}
